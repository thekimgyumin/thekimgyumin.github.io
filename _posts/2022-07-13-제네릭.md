---
layout: post
title: 제네릭
categories: JAVA
tags: [JAVA]
---
## 제네릭
타입을 클래스 내부에서 지정하는 것이 아닌 외부에서 사용자에 의해 지정되는 것

특정 타입을 미리 지정해주는 것이 아닌 필요에 의해 지정할 수 있도록 하는 일반 타입

### 장점
잘못된 타입이 들어올 수 있는 것을 컴파일 단계에서 방지할 수 있다

클래스 외부에서 타입을 지정해주기 때문에 따로 타입을 체크하고 변환해줄 필요가 없다(=관리하기 편하다)

비슷한 기능을 지원하는 경우 코드의 재사용성이 높아진다
- - -
## 사용방법
보통 제네릭은 아래 표의 타입들이 많이 쓰인다
|타입|설명|
|---|---|
|\<T>|Type|
|\<E>|Element|
|\<K>|Key|
|\<V>|Value|
|\<N>|Number|

### 선언 및 생성 방법
#### 1. 클래스 및 인터페이스 선언
```java
public class Classname <T> {...}
public Interface InterfaceName <T> {...}
```
기본적으로 제네릭 클래스나 인터페이스의 경우 위와 같이 선언한다

T 타입은 해당 블럭 {...} 안에서까지 유효하다

또한 여기서 더 나아가 제네릭 타입을 두 개로 둘 수 있다
```java
public class Classname <T, K> {...}
public Interface InterfaceName <T, K> {...}
```
이렇듯 데이터 타입을 외부로부터 지정할 수 있도록 할 수 있다

이렇게 생성된 제네릭 클래스를 사용하려면 객체를 생성해야 하는데 이때 구체적인 타입을 명시해야 한다
```java
public class ClassName <T, K> {...}

public class Main {
    public static void main(String[] args) {
        ClassName<String, Integer> a = new ClassName<String, Integer>();
    }
}
```
위 예시대로라면 T는 String가 되고, K는 Integer가 된다

이때 주의해야 할 점은 타입 파라미터로 명시할 수 있는 것은 참조 타입 밖에 올 수 없다. 즉 int, double, char 같은 primitive type은 올 수 없다는 것이다. 그래서 int형 double형 등 primitive type의 경우 Integer, Double 같은 Wrapper Type으로 쓰는 이유가 위와 같은 이유다

#### 2. 제네릭 클래스

```java
//제네릭 클래스
class ClassName<E> {
    private E element;  // 제네릭 타입 변수
    void set (E element) {   // 제네릭 파라미터 메소드
        this.element = element;
    }
    E get() {   // 제네릭 타입 변환 메소드
        return element;
    }
}

class Main {
    public static void main(String[] args) {

        ClassName<String> a = new ClassName<String>();
        ClassName<Integer> b = new ClassName<Integer>();

        a.set("10");
        b.set(10);

        System.out.println("a data : " + a.get());
        // 반환한 변수의 타입 출력
        System.out.println("a E Type : " + a.get().getClass().getName());

        System.out.println();
        System.out.println("b data : " + b.get());
        // 반환된 변수의 타입 출력
        System.out.println("b E Type : " + b.get().getClass().getName());
    }
}
```
보면 ClassName이란 객체를 생성할 때 <> 안에 타입 파라미터를 지정한다.

그러면 a객체의 ClassName의 E 제네릭 타입은 String으로 모두 변환된다.

반대로 b객체의 ClassName의 E 제네릭 타입은 Integer으로 모두 변환된다.

실제로 위 코드를 실행시키면 다음과 같이 출력된다.
```
first data : 10
K type : java.lang.String
Second data : 10
V type : java.lang.Integer
```
이렇게 외부 클래스에서 제네릭 클래스를 생성할 때 <> 괄호 안에 타입을 파라미터로 지정해 주는 것이 제네릭 프로그래밍이다.

#### 3. 제네릭 메소드

위 과정까지는 클래스 이름 옆에 예시로 <E>라는 제네릭 타입을 붙여 해당 클래스 내에서 사용할 수 있는 E타입으로 일반화를 했다. 그러나 그 외에 별도로 한정한 제네릭도 사용할 수 있다.

일반적으로 선언 방법은 다음과 같다.
```
public <T> T genericMethod(T o) {   // 제네릭 메소드
    ...
}
[접근 제어자] <제네릭 타입> [반환 타입] [메소드명] ([제네릭 타입] [파라미터]) {
    // 텍스트
}
```
클래스와는 다르게 반환 타입 이전에 <> 제네릭 타입을 선언한다.

위에서 다룬 제네릭 클래스에서 활용해보도록 하자.

```java
// 제네릭 클래스
class ClassName<E> {
    private E element;  // 제네릭 타입 변수
    void set(E element) {   // 제네릭 파라미터 메소드
        this.element = element;
    }
    E get() {   // 제네릭 타입 반환 메소드
        return element;
    }
    <T> T genericMethod(T o) { // 제네릭 메소드
        return o;
    }
}

public class Main {
    public static void main(String[] args) {
        ClassName<String> a = new ClassName<String>();
        ClassName<Integer> b = new ClassName<Integer>();

        a.set("10");
        b.set(10);

        System.out.println("a data : " + a.get());
        // 반환된 변수의 타입 출력
        System.out.println("a E Type : " + a.get().getClass().getName());

        System.out.println();
        System.out.println("b data : " + b.get());
        // 반환된 변수의 타입 출력
        System.out.println("B E Type :" + b.get().getClass().getName());
        Sysetm.out.println();

        // 제네릭 메소드 Integer
        System.out.println("<T> returnType : " + a.genericMethod(3).getClass().getName());

        // 제네릭 메소드 String
        System.out.println("<T> returnType : " + a.genericMethod("ABCD").getClass().getName());

        // 제네릭 메소드 ClassName b
        System.out.println("<T> returnType : " + a.genericMethod(b).getClass().getName());
    }
}
```
보면 ClassName이란 객체를 생성할 때 <> 안에 타입 파라미터를 지정한다.

그러면 a객체의 ClassName의 E 제네릭 타입은 모두 String으로 변환된다.

반대로 b객체의 ClassName의 E 제네릭 타입은 모두 Integer으로 변환된다.

genericMethod()는 파라미터 타입에 따라 T 타입이 결정된다.

실제로 위 코드를 실행시키면 다음과 같이 출력된다.
```
a data : 10
a E type : java.lang.String

b data : 10
b E type : java.lang.Integer

<T> returnType : java.lang.Integer
<T> returnType : java.lang.String
<T> returnType : ClassName
```
즉 클래스에서 지정한 제네릭 유형과 별도로 메소드에서 독립적으로 제네릭 유형을 선언하여 쓸 수 있다.

이렇게 위와 같은 방식이 필요한 이유는 '정적 메소드로 선언할 때 필요'하기 때문이다.

생각해보자. 앞서 제네릭은 유형을 외부에서 지정해 준다고 했다. 즉 해당 클래스 객체가 인스턴스화 했을 때, 쉽게 말해 new 생성자로 클래스를 생성하고 <> 괄호 사이에 파라미터로 넘겨준 타입으로 지정이 된다는 뜻이다.

하지만 static은 정적이라는 뜻이다. static 변수, static 함수 등 static이 붙은 것들은 기본적으로 프로그램 실행 시 메모리에 이미 올라가 있다.

이 말은 객체 생성을 통해 접근할 필요 없이 이미 메모리에 올라가 있기 때문에 클래스 이름을 통해 바로 쓸 수 있다는 것이다.

근데, 거꾸로 생각해 보면 static 메소드는 객체가 생성되기 전에 이미 메모리에 올라가는데 타입을 어디서 얻어올 수 있을까?
```java
class ClassName<E> {
    /*
    클래스와 같은 E 타입이더라도
    static 메소드는 객체가 생성되기 이전 시점에
    메모리에 먼저 올라가기 때문에
    E 유형을 클래스로부터 얻어올 방법이 없다.
    */
    static E genericMethod(E o) {   // error!
        return o;
    }
}

class Main {
    public static void main(String[] args) {
        // ClassName 객체가 생성되기 전에 접근할 수 있으나 유형을 지정할 방법이 없어 에러남
        ClassName.getnerMethod(3);
    }
}
```
위 내용을 보면 이해가 갈 것이다.

그렇기 때문에 제네릭이 사용되는 메소드를 정적 메소드로 두고 싶은 경우 제네릭 클래스와 별도로 독립적인 제네릭이 사용되어야 한다는 것이다.
```java
// 제네릭 클래스
class ClassName<E> {
    private E element; // 제네릭 타입 변수
    void set(E element) { // 제네릭 파라미터 메소드
        this.element = element;
    }

    E get() { // 제네릭 타입 반환 메소드
        return element;
    }

    // 아래 메소드의 E타입은 제네릭 클래스의 E타입과 다른 독립적인 타입이다.
    static <E> E genericMethod1(E o) { // 제네릭 메소드
        return o;
    }
    static <T> T genericMethod2(T o) { // 제네릭 메소드
        return o;
    }
}

public class Main {
    public static void main(String[] args) {
        ClassName<String> a = new ClassName<String>();
        ClassName<Integer> b = new ClassName<Integer>();

        a.set("10");
        b.set(10);

        System.out.println("a data : " + a.get());
        // 반환된 변수의 타입 출력
        System.out.println("a E type : " + a.get().getClass().getName());

        System.out.println();
        System.out.println("b data : " + b.get());
        // 반환된 변수의 타입 출력
        System.out.println("b E type : " + b.get().getClass().getName());
        System.out.println();

        // 제네릭 메소드1 Integer
        System.out.println("<E> returnType : " + ClassName.genericMethod1(3).getClass().getName());

        // 제네릭 메소드1 String
        System.out.println("<E> returnType : " + ClassName.genericMethod1("ABCD").getClass().getName());

        // 제네릭 메소드2 ClassName a
        System.out.println("<T> returnType : " + ClassName.genericMethod1(a).getClass().getName());

        // 제네릭 메소드2 Double
        System.out.println("<T> returnType : " + ClassName.genericMethod1(3.0).getClass().getName());
    }
}
```
결과는 다음과 같다.
```
a data : 10
a E type : java.lang.String

b data : 10
b E type : java.lang.Integer

<E> returnType : java.lang.Integer
<E> returnType : java.lang.String
<T> returnType : ClassName
<T> returnType : java.lang.Double
```
보다시피 제네릭 메소드는 제네릭 클래스 타입과 별도로 지정된다는 것을 볼 수 있다.